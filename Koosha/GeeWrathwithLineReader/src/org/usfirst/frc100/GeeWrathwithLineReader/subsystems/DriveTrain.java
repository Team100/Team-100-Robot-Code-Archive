// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc100.GeeWrathwithLineReader.subsystems;

import org.usfirst.frc100.GeeWrathwithLineReader.RobotMap;
import org.usfirst.frc100.GeeWrathwithLineReader.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Encoder lEncoder = RobotMap.driveTrainlEncoder;
    private final Encoder rEncoder = RobotMap.driveTrainrEncoder;
    private final Gyro gyro = RobotMap.driveTraingyro;
    private final AnalogChannel lReader = RobotMap.driveTrainlReader;
    private final AnalogChannel rReader = RobotMap.driveTrainrReader;
    private final AnalogTrigger lTrigger = RobotMap.driveTrainlTrigger;
    private final AnalogTrigger rTrigger = RobotMap.driveTrainrTrigger;
    private final Counter lCount = new Counter(lTrigger);
    private final Counter rCount = new Counter(rTrigger);
    private final SpeedController leftA = RobotMap.driveTrainleftA;
    private final SpeedController leftB = RobotMap.driveTrainleftB;
    private final SpeedController rightA = RobotMap.driveTrainrightA;
    private final SpeedController rightB = RobotMap.driveTrainrightB;
    private final RobotDrive drive = RobotMap.driveTraindrive;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final double inchesToCountRatio = 0.0125;
    private boolean reverse = true;
    private boolean lTriggered = true;
    private boolean rTriggered = true;
    private double distError;
    private double distOutput;
    private double angleError;
    private double angleOutput;
    private double direction;

    public DriveTrain()
    {
        lTrigger.setLimitsRaw(900, 910);
        rTrigger.setLimitsRaw(900, 910);
        lCount.setUpSourceEdge(true, true);
        rCount.setUpSourceEdge(true, true);
    }
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DrivewithJoysticks());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    // Encoders have to be started
    public void startEncoder()
    {
        lEncoder.start();
        rEncoder.start();
    }

    // Reset encoder value to Zero
    public void resetEncoder()
    {
        lEncoder.reset();
        rEncoder.reset();
    }

    // Inverse of the Start method
    public void stopEncoder()
    {
        lEncoder.stop();
        rEncoder.stop();
    }
    
    // Return distance traveled (if going straight)
    public double getDistance()
    {
        return (lEncoder.get() + rEncoder.get())*inchesToCountRatio;
    }

    // Resets Gyro angle to Zero
    public void resetGyro()
    {
        gyro.reset();
    }

    // Returns the angle of the Gyro
    public double getAngle()
    {
        return gyro.getAngle();
    }

    // inverts the reverse varible so the Drive Train will run backwards
    public void reverseDriveTrain()
    {
        reverse = !reverse;
    }

    public boolean getLeftTrigger()
    {
        return lTriggered;
    }
    
    public boolean getRightTrigger()
    {
        return rTriggered;
    }
    
    public void update()
    {
        lTriggered = 0==lCount.get()%2;
        rTriggered = 0==rCount.get()%2;
    }

    // param is in inches 
    // returns true when distance is reached
    public boolean autoDriveStraight(double distance)
    {
        // Distance output
        distError = distance - this.getDistance();

        if (Math.abs(distError) > 1.0) // false if distance goal has been reached
        {
            distOutput = distError*SmartDashboard.getNumber("DriveStraight_kP", 0);
        }
        else // if distance goal has been reached
        {
            distOutput = 0;
            if (Math.abs(angleError) < 5.0) // if correct angle has been reached
            {
                drive.stopMotor();
                angleOutput=0;
                //updateDashboard();
                return true;
            }
        }

        // Angle output
        angleError = direction - gyro.getAngle();
        while(angleError<0)
        {
            angleError+=360;
        }
        angleError = (angleError+180)%360-180;
        angleOutput = angleError*SmartDashboard.getNumber("AutoTurn_kP", 0);
        // Setting motors
        drive.arcadeDrive(distOutput, angleOutput);
        //updateDashboard();
        return false;
    }
}

